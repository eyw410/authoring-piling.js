!function (e, t) { "use strict"; function n(e, { enter: t, leave: n }) { return function e(t, n, u, c, p, f) { if (t) { if (u) { const e = r, c = s, m = o; r = !1, s = !1, o = null, u.call(a, t, n, p, f), o && i(n, p, f, t = o), s && l(n, p, f); const d = r, g = s; if (r = e, s = c, o = m, d) return t; if (g) return null } for (const n in t) { const r = t[n]; if ("object" == typeof r) if (Array.isArray(r)) for (let s = 0, o = 0; s < r.length; s += 1, o += 1)null !== r[s] && "string" == typeof r[s].type && (e(r[s], t, u, c, n, o) || s--); else null !== r && "string" == typeof r.type && e(r, t, u, c, n, null) } if (c) { const e = o, r = s; o = null, s = !1, c.call(a, t, n, p, f), o && i(n, p, f, t = o), s && l(n, p, f); const u = s; if (o = e, s = r, u) return null } } return t }(e, null, t, n) } let r = !1, s = !1, o = null; const a = { skip: () => r = !0, remove: () => s = !0, replace: e => o = e }; function i(e, t, n, r) { e && (null !== n ? e[t][n] = r : e[t] = r) } function l(e, t, n) { e && (null !== n ? e[t].splice(n, 1) : delete e[t]) } const u = "function require(id) {\n\tif (id in __repl_lookup) return __repl_lookup[id];\n\tthrow new Error(`Cannot require modules dynamically (${id})`);\n}"; var c = { name: "commonjs", transform: (e, r) => { if (/\b(require|module|exports)\b/.test(e)) try { const r = t.parse(e, { ecmaVersion: 9 }), s = []; n(r, { enter: e => { if ("CallExpression" === e.type && "require" === e.callee.name) { if (1 !== e.arguments.length) return; const t = e.arguments[0]; if ("Literal" !== t.type || "string" != typeof t.value) return; s.push(t.value) } } }); const o = s.map((e, t) => `import __repl_${t} from '${e}';`).join("\n"), a = `const __repl_lookup = { ${s.map((e, t) => `'${e}': __repl_${t}`).join(", ")} };`; return { code: [o, a, u, "const exports = {}; const module = { exports };", e, "export default module.exports;"].join("\n\n"), map: null } } catch (e) { return null } } }, p = { name: "glsl", transform: (e, t) => { if (t.endsWith(".glsl")) return { code: `export default ${JSON.stringify(e)};`, map: null } } }, f = { name: "json", transform: (e, t) => { if (t.endsWith(".json")) return { code: `export default ${e};`, map: null } } }; let m, d, g; self.window = self, self.addEventListener("message", e => { switch (e.data.type) { case "init": m = e.data.packagesUrl, d = e.data.svelteUrl, importScripts(d + "/compiler.js"); break; case "bundle": const { uid: t, components: n } = e.data; if (0 === n.length) return; g = t, setTimeout(async () => { if (g !== t) return; const e = await async function ({ uid: e, components: t }) { console.clear(), console.log("running Svelte compiler version %c" + svelte.VERSION, "font-weight: bold"); const n = {}; let r; t.forEach(e => { const t = `./${e.name}.${e.type}`; n[t] = e }); try { if (r = await _(e, "dom", h.dom, n), r.error) throw r.error; h.dom = r.cache; const t = (await r.bundle.generate({ format: "iife", name: "SvelteComponent", exports: "named", sourcemap: !0 })).output[0], s = null; if (s && (h.ssr = s.cache, s.error)) throw s.error; const o = s ? (await s.bundle.generate({ format: "iife", name: "SvelteComponent", exports: "named", sourcemap: !0 })).output[0] : null; return { uid: e, dom: t, ssr: o, imports: r.imports, warnings: r.warnings, error: null } } catch (t) { console.error(t); const n = t; return delete n.toString, { uid: e, dom: null, ssr: null, imports: null, warnings: r.warnings, error: Object.assign({}, n, { message: n.message, stack: n.stack }) } } }({ uid: t, components: n }); e.error !== w && e && t === g && postMessage(e) }) } }); let h = { dom: {}, ssr: {} }; const w = { aborted: !0 }, y = new Map; function v(e) { if (y.has(e)) return y.get(e); const t = fetch(e).then(async e => { if (e.ok) return { url: e.url, body: await e.text() }; throw new Error(await e.text()) }).catch(t => { throw y.delete(e), t }); return y.set(e, t), t } async function j(e) { return (await v(e)).url } function $(e, t, n) { const r = svelte.VERSION.match(/^(\d+)\.(\d+)\.(\d+)/); return r[1] - e || r[2] - t || r[3] - n } function b() { return $(3, 4, 4) <= 0 } async function _(t, n, r, s) { let o; const a = new Set, i = [], l = [], u = {}, h = { async resolveId(e, n) { if (t !== g) throw w; if ("svelte" === e) return d + "/index.mjs"; if (e.startsWith("svelte/")) return b() ? `${d}/${e.slice(7)}.mjs` : `${d}/${e.slice(7)}/index.mjs`; if (n && n.startsWith(d)) { const t = new URL(e, n).href; return t.endsWith(".mjs") ? t : b() ? t + ".mjs" : t + "/index.mjs" } if (e in s) return e; if (e + ".js" in s) return e + ".js"; if (e + ".json" in s) return e + ".json"; if (e.endsWith("/") && (e = e.slice(0, -1)), e.startsWith("http:") || e.startsWith("https:")) return e; if (e.startsWith(".")) { const r = new URL(e, n).href; return self.postMessage({ type: "status", uid: t, message: "resolving " + r }), await j(r) } if (self.postMessage({ type: "status", uid: t, message: "resolving " + e }), n in s) { const t = /^(@[^/]+\/)?[^/]+/.exec(e); t && a.add(t[0]) } try { const t = await j(`${m}/${e}/package.json`), n = (await v(t)).body, r = JSON.parse(n); if (r.svelte || r.module || r.main) { const e = t.replace(/\/package\.json$/, ""); return new URL(r.svelte || r.module || r.main, e + "/").href } } catch (e) { } return await j(`${m}/${e}`) }, async load(e) { if (t !== g) throw w; if (e in s) return s[e].source; y.has(e) || self.postMessage({ type: "status", uid: t, message: "fetching " + e }); return (await v(e)).body }, transform(e, s) { if (t !== g) throw w; if (self.postMessage({ type: "status", uid: t, message: "bundling " + s }), !/\.svelte$/.test(s)) return null; const o = s.split("/").pop().split(".")[0], a = r[s] && r[s].code === e ? r[s].result : svelte.compile(e, Object.assign({ generate: n, format: "esm", dev: !0, filename: o + ".svelte" }, $(3, 14, 0) >= 0 && { loopGuardTimeout: 100 })); return u[s] = { code: e, result: a }, (a.warnings || a.stats.warnings).forEach(e => { i.push({ message: e.message, filename: e.filename, start: e.start, end: e.end }) }), a.js } }; try { return o = await e.rollup({ input: "./App.svelte", plugins: [h, c, f, p], inlineDynamicImports: !0, onwarn(e) { l.push({ message: e.message }) } }), { bundle: o, imports: Array.from(a), cache: u, error: null, warnings: i, all_warnings: l } } catch (e) { return { error: e, imports: null, bundle: null, cache: u, warnings: i, all_warnings: l } } } }(rollup, acorn);
